# This makefile was originally generated by 'cbp2make' tool rev.147
# Edited by tehhowch - 2017-07-20
# 		for use by any and all

# Available targets:
# 'win64'   - a 64-bit optimized (-O2) version of Endless Sky
# 'release' - same as 'win64'
# 'debug'   - a 64-bit version of Endless Sky with debugging symbols (-g)
# 'all'     - compiles both targets
# 'clean'   - removes all compiled object files and .exe files
# 'dist'    - makes a general-release version of Endless Sky (non-specific architecture)


# Obtain the 'dev64' zip archive from the Endless Sky wiki:
# https://github.com/endless-sky/endless-sky/wiki/BuildInstructions
#
# The contents of the downloaded .zip should be placed in the C:\ directory
# or, modify the following line to reflect its true location:
#
DIR_ESLIB = C:\dev64


# 64-bit compiles should use the 'posix-seh' version of MinGW
# Always choose 'posix' instead of 'win32' (e.g. C++11 support).
#
# These paths point to a directory having 'bin' and 'lib' subfolders
# 	and inside the 'lib' subfolder should be 'libmingw32.a' and 'libopengl32.a'
#
#	(please note the 'escaped' space character!)
#
DIR_MINGW64 = C:\Program\ Files\mingw64\x86_64-w64-mingw32


# Path to the output directory (either relative or absolute).
# e.g. 	bin -> (working dir)\bin\Debug\EndlessSky.exe
#		bin -> (working dir)\bin\win64\EndlessSky.exe
OUT_DIR = bin


# Path to the Endless Sky source files
SOURCE_DIR = source


# General-purpose compiler flags (applied to all builds)
# 	Remove '-march=native' if building for general release.
#	'-march=native' should add in SSE support if available.
CFLAGS = -std=c++11 -Wall


#######
# You should not need to modify the lines below.
ifeq "$@" "release"
CFLAGS += -march=native
endif
OBJDIR = obj

CC = gcc.exe
CXX = g++.exe
AR = ar.exe
LD = g++.exe
WINDRES = windres.exe

INC = -I$(DIR_ESLIB)\include
RESINC =
LIBDIR = -L$(DIR_ESLIB)\lib
LIB = \
	$(DIR_MINGW64)\lib\libmingw32.a \
	$(DIR_MINGW64)\lib\libopengl32.a \
	$(DIR_ESLIB)\lib\libsdl2main.a \
	$(DIR_ESLIB)\lib\libsdl2.dll.a \
	$(DIR_ESLIB)\lib\libpng.dll.a \
	$(DIR_ESLIB)\lib\libturbojpeg.dll.a \
	$(DIR_ESLIB)\lib\libjpeg.dll.a \
	$(DIR_ESLIB)\lib\libmad.dll.a \
	$(DIR_ESLIB)\lib\libopenal32.dll.a \
	$(DIR_ESLIB)\lib\libglew32.dll.a
SRC = $(SOURCE_DIR)
LDFLAGS = -Wl,--subsystem,windows -lwinmm

INC_DEBUG = $(INC)
CFLAGS_DEBUG = $(CFLAGS) -g
RESINC_DEBUG = $(RESINC)
RCFLAGS_DEBUG = $(RCFLAGS)
LIBDIR_DEBUG = $(LIBDIR)
LIB_DEBUG = $(LIB)
LDFLAGS_DEBUG = $(LDFLAGS)
OBJDIR_DEBUG = $(OBJDIR)\Debug
DEP_DEBUG =
OUT_DEBUG = $(OUT_DIR)\Debug\EndlessSky.exe

INC_RELEASE = $(INC)
CFLAGS_RELEASE = $(CFLAGS) -O2
RESINC_RELEASE = $(RESINC)
RCFLAGS_RELEASE = $(RCFLAGS)
LIBDIR_RELEASE = $(LIBDIR)
LIB_RELEASE = $(LIB)
LDFLAGS_RELEASE = $(LDFLAGS) -s
OBJDIR_RELEASE = $(OBJDIR)\Win64
DEP_RELEASE =
OUT_RELEASE = $(OUT_DIR)\Win64\EndlessSky.exe


# Get all .cpp files in the source directory (.rc are built differently)
# Wildcard function needs forward slashes
SRCS ::= $(wildcard $(SRC)/*.cpp)

# Determine the names of the objects needed
# (For each file in SRCS, change the .cpp into .o, strip the source directory, and then append that filename to the object directory path)
OBJ_DEBUG ::= $(patsubst %, $(OBJDIR_DEBUG)\\%, $(notdir $(SRCS:.cpp=.o)))
OBJ_RELEASE ::= $(patsubst %, $(OBJDIR_RELEASE)\\%, $(notdir $(SRCS:.cpp=.o)))
# These objects do not come from .cpp files
OBJ_DEBUG += $(OBJDIR_DEBUG)\WinApp.o
OBJ_RELEASE += $(OBJDIR_RELEASE)\WinApp.o


# Build Target instructions
all: debug release

debug: before_debug out_debug after_debug

release: before_release out_release after_release

win64: release

dist: release

clean: clean_debug clean_release


# Directory preparation
before_debug:
	cmd /c if not exist $(OUT_DIR)\\Debug md $(OUT_DIR)\\Debug
	cmd /c if not exist $(OBJDIR_DEBUG) md $(OBJDIR_DEBUG)

before_release:
	cmd /c if not exist $(OUT_DIR)\\Win64 md $(OUT_DIR)\\Win64
	cmd /c if not exist $(OBJDIR_RELEASE) md $(OBJDIR_RELEASE)


after_debug:

after_release:

clean_debug:
	cmd /c del /f $(OBJ_DEBUG) $(OUT_DEBUG)
	cmd /c rd $(OUT_DIR)\\Debug
	cmd /c rd $(OBJDIR_DEBUG)

clean_release:
	cmd /c del /f $(OBJ_RELEASE) $(OUT_RELEASE)
	cmd /c rd $(OUT_DIR)\\Win64
	cmd /c rd $(OBJDIR_RELEASE)


# Output (linker) instructions
out_debug: before_debug $(OBJ_DEBUG) $(DEP_DEBUG)
	$(LD) $(LIBDIR_DEBUG) -o $(OUT_DEBUG) $(OBJ_DEBUG)  $(LDFLAGS_DEBUG) -mwindows $(LIB_DEBUG)

out_release: before_release $(OBJ_RELEASE) $(DEP_RELEASE)
	$(LD) $(LIBDIR_RELEASE) -o $(OUT_RELEASE) $(OBJ_RELEASE) $(LDFLAGS_RELEASE) -mwindows $(LIB_RELEASE)

out_win32: before_win32 $(OBJ_WIN32) $(OBJDIR_WIN32)\WinApp.o $(DEP_WIN32)
	$(LD) $(LIBDIR_WIN32) -o $(OUT_WIN32) $(OBJ_WIN32) $(LDFLAGS_WIN32) -mwindows $(LIB_WIN32)


# Compile instructions
$(OBJDIR_DEBUG)\\%.o: $(SRC)\\%.cpp $(SRC)\\%.h
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c $< -o $@

$(OBJDIR_DEBUG)\WinApp.o: $(SRC)\WinApp.rc
	$(WINDRES) -i $(SRC)\WinApp.rc -J rc -o $(OBJDIR_DEBUG)\WinApp.o -O coff $(INC_DEBUG)

$(OBJDIR_DEBUG)\main.o: $(SRC)\main.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c $(SRC)\main.cpp -o $(OBJDIR_DEBUG)\main.o


$(OBJDIR_RELEASE)\\%.o: $(SRC)\\%.cpp $(SRC)\\%.h
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c $< -o $@

$(OBJDIR_RELEASE)\WinApp.o: $(SRC)\WinApp.rc
	$(WINDRES) -i $(SRC)\WinApp.rc -J rc -o $(OBJDIR_RELEASE)\WinApp.o -O coff $(INC_RELEASE)

$(OBJDIR_RELEASE)\main.o: $(SRC)\main.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c $(SRC)\main.cpp -o $(OBJDIR_RELEASE)\main.o


.PHONY: before_debug after_debug clean_debug before_release after_release clean_release
